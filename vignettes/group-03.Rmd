---
title: "Part 3: Using cowplot to construct multi-panel figures"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{group-03}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
#library(ubcBIOL548L)

library(gapminder)
library(ggplot2)
library(tidyr)
library(dplyr)
library(tibble)
library(readr)
library(forcats)
library(readxl)

library(ggthemes)
library(magick)
library(grid)
library(cowplot)

library(ggmap)
library(maps)
```


```{r, include = FALSE}

  file.copy(system.file("extdata", "Fig3A_data.csv",
              package = "ubcBIOL548L"),
            "./Fig3A_data.csv")
  file.copy(system.file("extdata", "Fig3B_data.csv",
              package = "ubcBIOL548L"),
            "./Fig3B_data.csv")
  file.copy(system.file("extdata", "Fig3C_data.csv",
              package = "ubcBIOL548L"),
            "./Fig3C_data.csv")
  file.copy(system.file("extdata", "Fig3D_data.csv",
              package = "ubcBIOL548L"),
            "./Fig3D_data.csv")
  file.copy(system.file("extdata", "Fig3E_data.csv",
              package = "ubcBIOL548L"),
            "./Fig3E_data.csv")
  file.copy(system.file("extdata", "Fig3F_data.csv",
              package = "ubcBIOL548L"),
            "./Fig3F_data.csv")
```

## Introduction

This is an R workshop created for a graduate data visualization course at the 
University of British Columbia by Vikram Baliga, Andrea Gaede and 
Shreeram Senthivasan.  

There are three groups with increasing levels of difficulty. Each group has a 
set of learning opjectives.

## Group 3: Make a multi-panel figure with a clear narrative arc

### Learning Objectives:
1. Plan a sequence of plots that support a declarative statement of a result
2. Construct a multi-panel figure using cowplot
3. Evaluate which among a diversity of plotting options most effectively 
   communicates a logical argument

### Lesson:  
#### Prep work for figure legends:

**Bird head icons**
```{r}
icon_hb <- "graphics/hummingbird.png"
icon_zb <- "graphics/zeebie.png"
icon_pg <- "graphics/pigeon.png"

# Colours for the different birds
col_hb <- "#ED0080"
col_zb <- "#F48D00"
col_pg <- "#4AA4F2"

# Parts for drawing legends
rect_hb   <- rectGrob(width = 2, height = 1, gp = gpar(fill = col_hb))
rect_hb_t <- rectGrob(
               width = 2,
               height = 1,
               gp = gpar(fill = col_hb, alpha = 0.5)
             )
rect_zb   <- rectGrob(width = 2, height = 1, gp = gpar(fill = col_zb))
rect_zb_t <- rectGrob(
               width = 2,
               height = 1,
               gp = gpar(fill = col_zb, alpha = 0.5)
             )
rect_pg   <- rectGrob(width = 2, height = 1, gp = gpar(fill = col_pg))
point_hb  <- pointsGrob(
               x = 0,
               y = 0,
               pch = 24,
               size = unit(0.5, units = "char"),
               gp = gpar(fill = col_hb)
             )
point_zb  <- pointsGrob(
               x = 0,
               y = 0,
               pch = 21,
               size = unit(0.5, units = "char"),
               gp = gpar(fill = col_zb)
             )
```

#### Multi-panel figures can be driven by narrative
one example: raw data -> processing -> analyses -> punchline  

We will used Figure 3 from [Gaede et al. 2017 paper](https://www.cell.com/current-biology/fulltext/S0960-9822(16)31394-X) (Current Biology) as an example.  

This study examined how neurons in the lentiformis mesencephali (LM) brain region of three species of birds respond to visual motion across the retina.  

This figure shows that in hummingbirds, these neurons respond to faster visual motion speeds than those in zebra finches or pigeons.  

#### Figure 3 Panel A:
**Re-create panel A from Gaede et al. 2017**

```{r}
# First, import data
fig_A <-
  read_csv("./Fig3A_data.csv") %>%
  # Now take every nth data point (produces plot faster)
  filter(row_number() %% 5 == 0) %>%
  # Clean outliers
  filter(abs(spike) < 7 * sd(spike)) %>%
  ggplot(aes(time, spike)) +
    geom_path(size = 0.1) +
    theme_void() +
    # Y-axis vertical scale
    annotate(geom = "segment",
             y = 0.00278 - 0.01, yend = 0.00278 + 0.01,
             x = -1.5, xend = -1.5,
             lwd = 1.2) +
    # Y-axis scale label
    annotate(geom = "text", y = 0.00278, x = -3,
             label = "0.2 mV", size = 5, angle = 90) +
    # X-axis scale bar
    annotate(geom = "segment",
             y = -0.035, yend = -0.035,
             x = 70 + 1.5, xend = 75 + 1.5,
             lwd = 1.2) +
    # X-axis scale label
    annotate(geom = "text", y = -0.04, x = 74,
             label = "5s", size = 5) +
    # Large ticks
    annotate(geom = "segment",
             y = -0.03, yend = -0.025,
             x = 1.5 + 1:15 * 5, xend = 1.5 + 1:15 * 5,
             lwd = 1) +
    # Small ticks within large ticks
    annotate(geom = "segment",
             y = -0.027, yend = -0.028,
             x = 1.5 + 1:79, xend = 1.5 + 1:79,
             lwd = 0.8) +
    # Arrows
    annotate(
      geom = "segment",
      y = -0.0275,
      yend = -0.0275,
      x = -10 + 2.5 + 1:8 * 10,
      xend = -10 + 5.5 + 1:8 * 10,
      lwd = 1.2,
      arrow = arrow(
        # Control the direction of each arrow. first = left; last = right
        ends = c("first", "last", "last", "last",
                 "first", "first", "first", "last"),
        # Control the size of each arrow head
        length = unit(c(1, 6, 10, 10, 6, 10, 1, 6), "pt"),
        type = "closed"
        ),
      # Use 'sharp' arrow heads
      linejoin = 'mitre')
fig_A
```

### Create and save panels as separate `ggplot` objects
#### Figure 3 Panel B:
```{r, echo=FALSE, warning=FALSE,message=FALSE}
## Build the theme
theme_548 <- theme_classic() +
    theme(
      # Text
      axis.title = element_text(size = 13),
      axis.text = element_text(size = 13, colour = "black"),
      axis.text.x = element_text(margin = margin(t = 10, unit = "pt")),
      axis.text.y = element_text(margin = margin(r = 10)),
      # Axis line
      axis.line = element_blank(),
      axis.ticks.length = unit(-5,"pt"),
      # Legend
      legend.position = 'none',
      # Background transparency
        # Background of panel
      panel.background = element_rect(fill = "transparent"),
        # Background behind actual data points
      plot.background = element_rect(fill = "transparent", color = NA)
    )

fudge_axis_BC <- tibble(speed = c(-0.5,2), firing_rate = c(-1,2))

data_B_raw <- read_csv("Fig3B_data.csv") %>%
  gather(key = bin, value = count, starts_with("bin")) %>%
  group_by(trial, direction, speed) %>%
  summarize(
    raw_firing_rate = mean(count)
  ) %>%
  ungroup()

baseline <- data_B_raw %>%
  filter(direction == 'NaN') %>%
  pull(raw_firing_rate) %>%
  mean

data_B <- data_B_raw %>%
  filter(direction != 'NaN') %>%
  mutate(
    norm_firing_rate = raw_firing_rate - baseline,
    norm_firing_rate = norm_firing_rate / max(abs(norm_firing_rate))
  ) %>%
  group_by(direction, speed) %>%
  summarize(
    firing_rate = mean(norm_firing_rate),
    sem = sd(norm_firing_rate) / sqrt(n())
  ) %>%
  ungroup() %>%
  mutate(direction = as_factor(direction))

fig_B <- data_B %>%
  ggplot(aes(x = speed, y = firing_rate)) +
    # Plot data and threshold
    geom_hline(
      yintercept = 0.8 * max(data_B$firing_rate),
      colour = 'grey70',
      linetype = 'dashed'
    ) +
    geom_line(aes(colour = direction)) +
    geom_errorbar(
      aes(
        colour = direction,
        ymin = firing_rate - sem,
        ymax = firing_rate + sem
      ),
      width = 0.02
    ) +
    geom_point(aes(colour = direction, shape = direction, size = direction)) +
    # Annotate points over threshold
    annotate(
      geom = 'segment',
      x = 1.3, xend = 1.78,
      y = 1.2, yend = 1.2,
      size = 0.7,
      arrow = arrow(ends = 'both', length = unit(2, "pt"), angle = 90)
    ) +
    # Select colours and shapes
    scale_colour_manual(values = c("black", "grey50")) +
    scale_shape_manual(values = c(15, 18)) +
    scale_size_manual(values = c(2, 3)) +
    # Text
    labs(y = "Normalized\nfiring rate", x = "") +
    # Theme
    theme_548 +
    # Axes
    geom_rangeframe(data = fudge_axis_BC) +
    lims(y = c(-1,2)) +
    scale_x_continuous(breaks = -1:4 / 2)
fig_B
```

#### Figure 3 Panel C:

```{r, echo=FALSE, warning=FALSE,message=FALSE}
data_C_raw <- read_csv("Fig3C_data.csv") %>%
  gather(key = bin, value = count, starts_with("bin")) %>%
  group_by(trial, direction, speed) %>%
  summarize(
    raw_firing_rate = mean(count)
  ) %>%
  ungroup()

baseline <- data_C_raw %>%
  filter(direction == 'NaN') %>%
  pull(raw_firing_rate) %>%
  mean

data_C <- data_C_raw %>%
  filter(direction != 'NaN') %>%
  mutate(
    norm_firing_rate = raw_firing_rate - baseline,
    norm_firing_rate = norm_firing_rate / max(abs(norm_firing_rate))
  ) %>%
  group_by(direction, speed) %>%
  summarize(
    firing_rate = mean(norm_firing_rate),
    sem = sd(norm_firing_rate) / sqrt(n())
  ) %>%
  ungroup() %>%
  mutate(direction = as_factor(direction))

fig_C <- data_C %>%
  ggplot(aes(x = speed, y = firing_rate)) +
    # Plot data and threshold
    geom_hline(
      yintercept = 0.8 * max(data_C$firing_rate),
      colour = 'grey70', linetype = 'dashed'
    ) +
    geom_line(aes(colour = direction)) +
    geom_errorbar(
      aes(
        colour = direction,
        ymin = firing_rate - sem,
        ymax = firing_rate + sem
      ),
      width = 0.02
    ) +
    geom_point(aes(colour = direction, shape = direction, size = direction)) +
    # Annotate points over threshold
    annotate(
      geom = "segment",
      x = 0.5, xend = 1.9,
      y = 1.2, yend = 1.2,
      size = 0.7,
      arrow = arrow(ends = 'both', length = unit(2, "pt"), angle = 90)
    ) +
    # Select colours and shapes
    scale_colour_manual(values = c("black", "grey50")) +
    scale_shape_manual(values = c(15, 18)) +
    scale_size_manual(values = c(2, 3)) +
    # Text
    labs(y = "Normalized\nfiring rate", x = "log(degrees/s)") +
    #theme(axis.title.x = element_blank()) +
    # Theme
    theme_548 +
    # Axes
    geom_rangeframe(data = fudge_axis_BC) +
    lims(y = c(-1,2)) +
    scale_x_continuous(breaks = -1:4 / 2)
fig_C
```

#### Figure 3 Panel D:

```{r, echo=FALSE, warning=FALSE,message=FALSE}
data_D <- read_csv("Fig3D_data.csv") %>%
  mutate(
    perc_firing = perc_firing * 100,
    perc_firing = as_factor(perc_firing)
  )

fig_D <- data_D %>%
  ggplot(aes(x = perc_firing, y = num_bins, fill = species)) +
    geom_boxplot(alpha = 0.5, outlier.size = 0) +
    geom_point(
      aes(shape = species),
      position = position_jitterdodge(jitter.height = 0.3, jitter.width = 0.2)
    ) +
    scale_fill_manual(values = c(col_hb, col_zb)) +
    scale_shape_manual(values = c(24, 21)) +
    labs(
      x = "Percent of maximum firing rate (threshold)",
      y = "Number of speed bins above threshold"
    ) +
    theme_548 +
    geom_rangeframe() +
    annotate(geom = "segment", x = 0, xend = 0, y = 2.5, yend = 10)
fig_D
```

#### Figure 3 Panel E:
```{r, echo=FALSE, warning=FALSE,message=FALSE}
data_E <- read_csv("./Fig3E_data.csv") %>%
  mutate(species = c("hb", "zb", "pg")) %>%
  gather(key = speed, value = prop, -species)

data_E <- data_E %>%
  mutate(
    species = fct_relevel(species, c("hb","zb","pg")),
    speed = as_factor(as.numeric(speed))
  )

fig_E <- data_E %>%
  ggplot(aes(x = speed, y = prop, fill = species)) +
    # Plot data
    geom_col(
      position = position_dodge(0.75),
      width = 0.75,
      size = 0.2,
      colour = "black"
    ) +
    # Pick colours
    scale_fill_manual(values = c(col_hb, col_zb, col_pg)) +
    # Text
    labs(
      x = "Speed bins (degrees/s)",
      y = "Proportion of LM\ncell population"
    )+
    # Theme
    theme_548 +
    # Axes
    theme(
      axis.ticks.x = element_blank(),
      axis.text.x = element_text(margin = margin(t = 0))
    ) +
    geom_rangeframe(sides = 'l')
fig_E
```

#### Figure 3 Panel F:
```{r, echo=FALSE, warning=FALSE,message=FALSE}
speeds_F <- c(0.24,0.5,1,2,4,8,16,24,32,48,64,80)
data_F <- read_csv("./Fig3F_data.csv") %>%
  filter(!is.na(dir1.area))  %>%
  select(starts_with("sp")) %>%
  rename_all(~c("species",as.character(speeds_F))) %>%
  mutate(
    species = case_when(
      species == 1 ~ "zb",
      species == 2 ~ "hb"
    )
  ) %>%
  gather(key = speed, value = prop, -species) %>%
  group_by(species, speed) %>%
  summarise(prop = mean(prop)) %>%
  ungroup %>%
  mutate(
    species = fct_relevel(species, c('hb', 'zb')),
    speed = as_factor(as.numeric(speed))
  )

fig_F <- data_F %>%
  ggplot(aes(x = speed, y = prop, fill = species)) +
    # Plot data
    geom_col(
      position = position_dodge(0.75),
      width = 0.75,
      size = 0.2,
      colour = "black"
    ) +
    # Pick colours
    scale_fill_manual(values = c(col_hb, col_zb)) +
    # Text
    labs(
      x = "Speed bins (degrees/s)",
      y = "Proportion of LM\ncell population"
    ) +
    # Theme
    theme_548 +
    # Axes
    theme(
      axis.ticks.x = element_blank(),
      axis.text.x = element_text(margin = margin(t = 0))
    ) +
    geom_rangeframe(sides = 'l')
fig_F
```

#### Intro to cowplot

We'll go over `plot_grid()` basics.  
`draw_image()` & `draw_grob()` can also be used with `ggplot()` & `plot_grid()`

**Basics**  

* Multiple panels can be combined via `cowplot::plot_grid()`
* Each panel should be saved as a separate ggplot object beforehand and then each will be fed in as an argument to `plot_grid()`

**Plot objects can be added sequentially**
```{r}
plot_grid(fig_B, fig_C)
```

**By default, additional panels are initially added within the same row.**  
`plot_grid()` then tends to prefer to have ncol = nrow as best as possible:  
```{r}
plot_grid(fig_B, fig_C, fig_E,
          labels=c("1","2","3"))
plot_grid(fig_B, fig_C, fig_E, fig_F,
          labels=c("1","2","3","4"))
plot_grid(fig_B, fig_C, fig_E, fig_F, fig_B,
          labels=c("1","2","3","4","5"))
plot_grid(fig_B, fig_C, fig_E, fig_F, fig_B, fig_C,
          labels=c("1","2","3","4","5","6"))
plot_grid(fig_B, fig_C, fig_E, fig_F, fig_B, fig_C, fig_E,
          labels=c("1","2","3","4","5","6","7"))
```

**This looks okay, but we may prefer to have the plots arranged in one column.**  
Let's first just focus on panels E and F.  
```{r}
plot_grid(fig_E, fig_F,
          ncol = 1)
```

**Cowplot also allows you to add labels to panels as you'd see in a journal article.**  
```{r}
plot_grid(fig_E, fig_F,
          ncol = 1,
          labels = c("E","F"))
```

**See the arguments of `cowplot::plot_grid()` to see how labels can be adjusted.**  
We'll adjust the size and (temporarily) change to a serif font.  
```{r}
plot_grid(fig_E, fig_F,
          ncol = 1,
          labels = c("E","F"),
          label_size = 40,
          label_fontfamily = "serif")
```

#### Re-create Gaede et al. 2017 Fig 3

##### Let's try to build Fig 3 from [Gaede et al. 2017](https://www.cell.com/current-biology/fulltext/S0960-9822(16)31394-X)

The layout of the figure is complex; nrows and ncols can't be set easily. Luckily we can build sets of panels together, save each one, then stitch it all together at the end.  

**Let's start with panels E and F.**  
```{r}
cow_EF <- plot_grid(fig_E, fig_F,
                    ncol = 1,
                    labels = c("E","F"),
                    label_size = 18,
                    label_fontfamily = "sans")
cow_EF
```

**For panel A, we'll adjust the padding around the margin.**  
Within the argument `plot.margin`, the order is top, right, bottom, left; think TRouBLe (T,R,B,L)

```{r}
fig_A <- fig_A + theme(plot.margin = unit(c(5.5, 5.5, 0, 5.5), units = "pt"))
cow_A <- plot_grid(NULL, fig_A,
                   rel_widths = c(0.07, 0.93),
                   nrow = 1,
                   labels = c("A",""),
                   label_size = 18,
                   label_fontfamily = "sans")
cow_A
```

**Panels B and C**  
When combining B and C, we should note that C has an x-axis label but B does not. Therefore, we will add blank plots (NULL) as padding and then adjust the relative heights to fit things comfortably. We still need to supply 4 labels, so "" will be used for blank plots.  
```{r}
cow_BC <- plot_grid(NULL, fig_B, NULL, fig_C,
                    rel_heights = c(0.1, 1, -0.15, 1),
                    ncol = 1,
                    label_y = 1.07,
                    labels = c("","B","","C"),
                    label_size = 18,
                    label_fontfamily = "sans")
cow_BC
```

**Panel D**  
Similarly, with panel D, we'll add a NULL object to the cowplot and adjust the relative heights to the proportions we'd like.  
```{r}
fig_D <- fig_D + labs(y = "Number of speed bins above threshold    ")
cow_D <- plot_grid(NULL, fig_D,
                    rel_heights = c(0.1, 1.85),
                    ncol = 1,
                    label_y = 1 + 0.07 /1.85,
                    labels = c("","D"),
                    label_size = 18,
                    label_fontfamily = "sans")
cow_D
```

**You can cowplot multiple cowplots**  
```{r}
cow_BCD <- plot_grid(cow_BC, cow_D,
                     rel_widths = c(2,3),
                      nrow = 1)
cow_BCD
```

##### Now combine all the panels together:

It may help to specify the dimensions of the plot window to ensure that the plot is made with correct overall proportions.  
try(`dev.off(), silent = T`)  
`dev.new(width = 8, height = 11, units = "in")`

**Now for the plot itself:**  
```{r fig.height=11, fig.width=8.5}
cow_A2F <- plot_grid(cow_A, NULL, cow_BCD, cow_EF,
          ncol = 1,
          # A negative rel_height shrinks space between elements
          rel_heights = c(1.2, -0.2, 2.5, 3),
          label_size = 18,
          label_fontfamily = "sans")
cow_A2F
```

##### Adding icons to a multipanel plot:

The bird heads and other legend elements are conspicuously absent. The `cowplot::draw_image()` function allows for an image to be placed on the canvas, which we'll use for the bird heads.  

Similarly, `cowplot::draw_grob()` places grobs (GRaphical OBjects). We'll use this to add in colored rectangles for the legends.  

Each image's (or grob's) location is specified with x- and y- coordinates. Each runs from 0 to 1, with (0,0) being the lower left corner of the canvas.  

At the moment, vectorization of the code you see below doesn't seem possible. It's a bit tedious (and un-tidy!) but it works!  
